<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Dr Joseph Barraud">
<meta name="dcterms.date" content="2016-12-15">

<title>How to add maps to OpendTect? – josephbarraud.dev</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../rockall_bathy_64x64.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">josephbarraud.dev</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/jobar8" rel="me"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/josephbarraud"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#method" id="toc-method" class="nav-link" data-scroll-target="#method">Method</a></li>
  <li><a href="#example-the-kevitsa-deposit-northern-finland" id="toc-example-the-kevitsa-deposit-northern-finland" class="nav-link" data-scroll-target="#example-the-kevitsa-deposit-northern-finland">Example: the Kevitsa Deposit, northern Finland</a>
  <ul class="collapse">
  <li><a href="#georeferencing" id="toc-georeferencing" class="nav-link" data-scroll-target="#georeferencing">Georeferencing</a></li>
  </ul></li>
  <li><a href="#color-quantization" id="toc-color-quantization" class="nav-link" data-scroll-target="#color-quantization">Color Quantization</a>
  <ul class="collapse">
  <li><a href="#palette" id="toc-palette" class="nav-link" data-scroll-target="#palette">Palette</a></li>
  <li><a href="#pairwise-distance" id="toc-pairwise-distance" class="nav-link" data-scroll-target="#pairwise-distance">Pairwise distance</a></li>
  </ul></li>
  <li><a href="#cropping-and-resampling" id="toc-cropping-and-resampling" class="nav-link" data-scroll-target="#cropping-and-resampling">Cropping and Resampling</a>
  <ul class="collapse">
  <li><a href="#survey-definition" id="toc-survey-definition" class="nav-link" data-scroll-target="#survey-definition">Survey definition</a></li>
  <li><a href="#interpolation" id="toc-interpolation" class="nav-link" data-scroll-target="#interpolation">Interpolation</a></li>
  </ul></li>
  <li><a href="#importing-the-grid-into-opendtect" id="toc-importing-the-grid-into-opendtect" class="nav-link" data-scroll-target="#importing-the-grid-into-opendtect">Importing the grid into OpendTect</a></li>
  <li><a href="#displaying-the-map-in-opendtect" id="toc-displaying-the-map-in-opendtect" class="nav-link" data-scroll-target="#displaying-the-map-in-opendtect">Displaying the map in OpendTect</a>
  <ul class="collapse">
  <li><a href="#loading-the-correct-colormap" id="toc-loading-the-correct-colormap" class="nav-link" data-scroll-target="#loading-the-correct-colormap">Loading the correct colormap</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#acknowledgements" id="toc-acknowledgements" class="nav-link" data-scroll-target="#acknowledgements">Acknowledgements</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">How to add maps to OpendTect?</h1>
  <div class="quarto-categories">
    <div class="quarto-category">geophysics</div>
    <div class="quarto-category">python</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Dr Joseph Barraud </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 15, 2016</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>This post is associated with a couple of <a href="https://github.com/jobar8/Geophysics-Labs-Notebooks/blob/master/notebooks/">Jupyter notebook</a> available on GitHub.</p>
</div>
</div>
<p><a href="http://opendtect.org/">OpendTect</a> is a great piece of software that allows you to load, process and interpret seismic data. In OpendTect, 2D lines and 3D volumes are displayed in a nice 3D environment that is easy to manipulate.&nbsp;Horizons, either 2D (lines) or 3D (surfaces) can be added to the 3D view&nbsp;alongside the seismic data.</p>
<p>In fact, any grid, not just seismic horizons, can be loaded in the OpendTect environment. This makes it ideal for displaying data from gravity and magnetic surveys.&nbsp;As a potential-field specialist, I am then able to compare directly the position of gravity and magnetic anomalies with the features that I see&nbsp;on seismic data.</p>
<p>While loading grids in OpendTect could be a tutorial on its own, in this post I will actually add one more difficulty by explaining how to load pictures, typically geological maps, to the 3D view. The solution I am proposing allows you&nbsp;to retain the original colours of the map (or at least most of them).</p>
<p>A map is typically created in a program like ArcGIS or <a href="http://qgis.org/">QGIS</a> and exported as an RGB coloured image, therefore containing 3 channels or bands (red, green and blue). The problem is that OpendTect cannot handle this type of image, it deals only with basic one-band grids. When&nbsp;they are rendered by OpendTect, one-band grids may appear in colours because the data are colour-coded (or <em>mapped</em>) to a list of colours, a colormap. Colormaps therefore help us to visualise the various intensities of the quantity contained in the grid. Note that we could also display a one-band grid&nbsp;with a grayscale, demonstrating it carries only intensity information.</p>
<p>So the trick to display RGB images in OpendTect is to merge the three bands into one, trying in the process not to lose too much information about the colours. This process is called <a href="https://en.wikipedia.org/wiki/Color_quantization">colour quantization</a>, or colour-depth reduction, and consists in finding for&nbsp;each colour in an image its closest match in a limited set of (predefined or not) colours.</p>
<p>The result is also called an <a href="https://en.wikipedia.org/wiki/Indexed_color">indexed colour image</a> because the colour information is stored in a separate file called a palette. The one-band grid therefore contains indices (or positions) representing a colour in the palette.</p>
<p>There are many methods and algorithms to achieve this result and the one I am proposing is specially targeting geological maps. These maps already contain a relatively small number of different colours: they represent the various types of rocks in an area, and, unless your area is particularly complex, there should be fewer than a hundred types (or ages, or whatever has been mapped). So the quantization should work pretty well in this case.</p>
</section>
<section id="method" class="level2">
<h2 class="anchored" data-anchor-id="method">Method</h2>
<p>To summarise what needs to be done to get a coloured map into OpendTect, here is a breakdown of the method:</p>
<ol type="1">
<li>Prepare the RGB image of the map.</li>
<li>Convert the image from RGB to indexed colour&nbsp;using color quantization.</li>
<li>Crop and resample the image to fit the OpendTect survey area.</li>
<li>Import into OpendTect.</li>
</ol>
<p>The first step could involve extracting a picture&nbsp;from a PDF file, or exporting an&nbsp;image from a GIS application.&nbsp;Additionally, the map might also need to be georeferenced and/or projected in the same coordinate system as the seismic data. We&nbsp;will assume in the following that this stage has already been completed.</p>
</section>
<section id="example-the-kevitsa-deposit-northern-finland" class="level2">
<h2 class="anchored" data-anchor-id="example-the-kevitsa-deposit-northern-finland">Example: the Kevitsa Deposit, northern Finland</h2>
<p>In order to describe the method more efficiently, I am using an example based on some data&nbsp;that have recently been made freely available thanks to the&nbsp;<a href="https://www.frankarnottaward.com">Frank Arnott award</a>. It is a complete geophysical dataset that has been&nbsp;used for the exploration of the Kevitsa intrusion in Finland (Malehmir et al., 2012). It contains a 3D reflection seismic survey, potential-field survey data, wells, geological maps and cross-sections.</p>
<p>The mafic-ultramafic intrusion has an elliptical shape in map view and the 3D seismic survey is located on its north-east side (<a href="#fig-kevitsa_geology_map" class="quarto-xref">Figure&nbsp;1</a>). The intrusion is surrounded by&nbsp;sedimentary and volcanic rocks that are both folded and faulted. The seismic data were used to image the contact between the intrusion and the adjacent units, as well as&nbsp;the geometry of the intrusion at depth (Koivisto et al., 2015).</p>
<div id="fig-kevitsa_geology_map" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-kevitsa_geology_map-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/Kevitsa_geology_map_QGIS_s.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="Figure&nbsp;1: Geological map of the Kevitsa area, with the 3D reflection seismic survey area shown in red (after Koivisto et al., 2015)."><img src="images/Kevitsa_geology_map_QGIS_s.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-kevitsa_geology_map-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Geological map of the Kevitsa area, with the 3D reflection seismic survey area shown in red (after Koivisto et al., 2015).
</figcaption>
</figure>
</div>
<p>So the purpose of this exercise is to have an image of the geological map rendered together with the seismic data in a 3D environment. The first stage of this process is to extract a portion of this map centred on the 3D survey. The legend, the scale and other annotations are superfluous for this purpose, as only the geological information is required (<a href="#fig-kevitsa_geology_noframe" class="quarto-xref">Figure&nbsp;2</a>).</p>
<div id="fig-kevitsa_geology_noframe" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-kevitsa_geology_noframe-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/Kevitsa_geology_noframe.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Figure&nbsp;2: Image of the geological map centred on the 3D survey."><img src="images/Kevitsa_geology_noframe.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-kevitsa_geology_noframe-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Image of the geological map centred on the 3D survey.
</figcaption>
</figure>
</div>
<section id="georeferencing" class="level3">
<h3 class="anchored" data-anchor-id="georeferencing">Georeferencing</h3>
<p>It&nbsp;is <strong>essential</strong> for the final step of the method (interpolation onto the OpendTect survey grid) to have the geographic coordinates of the image, i.e.&nbsp;its location and its extent. This information will be contained in a <a href="https://en.wikipedia.org/wiki/World_file"><em>world file</em></a> that is automatically created by QGIS or by ArcGIS when the map is exported to a PNG file. Look for a small .pgw text file with the same name as the PNG file. These two files (the .png and the .pgw) always need to sit together on your drive.</p>
</section>
</section>
<section id="color-quantization" class="level2">
<h2 class="anchored" data-anchor-id="color-quantization">Color Quantization</h2>
<p>This is the conversion of our RGB image to a one-channel image using a specific set of&nbsp;colours.</p>
<section id="palette" class="level3">
<h3 class="anchored" data-anchor-id="palette">Palette</h3>
<div id="fig-win256_colomap" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-win256_colomap-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/Win256_colomap.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="Figure&nbsp;3: The 256 colours of the Windows 8-bit colour palette."><img src="images/Win256_colomap.png" class="img-fluid figure-img" style="width:70.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-win256_colomap-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: The 256 colours of the Windows 8-bit colour palette.
</figcaption>
</figure>
</div>
<p>I am using a fixed palette of 256 colours. Fixing the colours can potentially degrade the performance of the quantization process, but this is essential for OpendTect to render our images consistently. It is also much simpler, as the alternative would be to have a different palette for each image, which is impractical.</p>
<p>This palette is the classic Windows palette (<a href="#fig-win256_colomap" class="quarto-xref">Figure&nbsp;3</a>). It contains a number of shades of red, green and blue-ish colours, and also the typical set of basic colours that are found in lots of Windows programs. A text file with the RGB colours of the palette can be found <a href="files/windows_256_color_palette_rgb.txt">here</a>.</p>
</section>
<section id="pairwise-distance" class="level3">
<h3 class="anchored" data-anchor-id="pairwise-distance">Pairwise distance</h3>
<p>The quantization can be simply performed with a function of the&nbsp;<a href="http://scikit-learn.org/stable/index.html">scikit-learn</a>&nbsp;Python library. Its <a href="http://scikit-learn.org/stable/modules/classes.html#pairwise-metrics">metrics</a> sub-module contains functions to compute distances between objects. We need a function that can tell us the colour in the palette that is the closest to the colour of each pixel in our RGB image.</p>
<p>This function is called&nbsp;<code>pairwise_distances_argmin</code> and using it for color quantization is straightforward. Here is the gist of the method in Python code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> pairwise_distances_argmin</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>indices <span class="op">=</span> pairwise_distances_argmin(flat_array, win256)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>indexedImage <span class="op">=</span> indices.reshape((nrows, ncols))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here, <code>win256</code> is a 3-column array containing the 256 colours of the Windows palette. It is compared with <code>flat_array</code>, which is a reshaped version of our initial RGB image. The result is a list of indices pointing at the colours in our palette. To get our final grid, we finally need to reshape the result back to a rectangular array that has the same dimensions as the initial image.</p>
<p>A more complete version of the code is available in this <a href="https://nbviewer.jupyter.org/github/jobar8/Geophysics-Labs-Notebooks/blob/master/notebooks/01_Color_quantization_with_sklearn.ipynb">Jupyter notebook</a>.</p>
<p>The result is our quantization method is quite good and looks almost identical to the original (<a href="#fig-kevitsa_geology_noframe_oneband" class="quarto-xref">Figure&nbsp;4</a>). Of course, in order to display it properly we also need to have the Windows 8-bit palette loaded as a colormap in matplotlib (see the notebook for the details).</p>
<div id="fig-kevitsa_geology_noframe_oneband" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-kevitsa_geology_noframe_oneband-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/Kevitsa_geology_noframe_oneband.png" class="lightbox" data-gallery="quarto-lightbox-gallery-4" title="Figure&nbsp;4: Indexed-colour image of the Kevitsa geological map."><img src="images/Kevitsa_geology_noframe_oneband.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-kevitsa_geology_noframe_oneband-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Indexed-colour image of the Kevitsa geological map.
</figcaption>
</figure>
</div>
</section>
</section>
<section id="cropping-and-resampling" class="level2">
<h2 class="anchored" data-anchor-id="cropping-and-resampling">Cropping and Resampling</h2>
<p>Having the RGB image converted to a one-band grid is only one part of the process of importing the map into OpendTect. The other non-trivial bit is to make sure the position and sampling of the grid correspond exactly with the grid that defines the “Survey” in OpendTect. As the OpendTect&nbsp;<a href="http://doc.opendtect.org/6.0.0/doc/od_userdoc/Default.htm#getting_started/system_overview.htm">documentation</a> puts it: “<em>Projects are organized in Surveys - geographic areas with a defined grid that links X,Y co-ordinates to inline, crossline positions. 3D seismic volumes must lie within the defined survey boundaries.</em>”</p>
<p>From this point onwards, there are two possibilities: either you have an actual 3D seismic volume loaded in your project, or you have only 2D seismic lines. In the first scenario, the 3D volume dictates the geometry of the OpendTect survey. In the latter case, you are actually free to define the survey grid, since “<em>2D lines and wells are allowed to stick outside the survey box</em>”.</p>
<section id="survey-definition" class="level3">
<h3 class="anchored" data-anchor-id="survey-definition">Survey definition</h3>
<p>So for the simple 2D case, my advice is generally to use a grid that defines a rectangle area that encompasses most or all the 2D lines. The grid needs to be in the same projected coordinate system as the seismic. The common scenario is that a gravity or a magnetic survey is available in the area, so this is the grid that should be used for the OpendTect survey.</p>
<div id="fig-ODT_survey_definition" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ODT_survey_definition-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/ODT_survey_definition.png" class="lightbox" data-gallery="quarto-lightbox-gallery-5" title="Figure&nbsp;5: Screenshot from OpendTect showing the parameters used to define the survey area that corresponds to the Kevitsa 3D seismic data."><img src="images/ODT_survey_definition.png" class="img-fluid figure-img" style="width:70.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ODT_survey_definition-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: Screenshot from OpendTect showing the parameters used to define the survey area that corresponds to the Kevitsa 3D seismic data.
</figcaption>
</figure>
</div>
<p>In contrast, 3D seismic surveys come in all sorts of shape and orientation so a mismatch is likely to occur between the survey grid and the map we want to import. Cropping and resampling the map are therefore necessary.</p>
<p>In the Kevitsa example, the outline of the seismic cube makes an angle of about 20 degrees with the north. In OpendTect, the Survey grid is created by scanning the coordinates of the traces in the SEGY file. The result shows that the grid comprises 280 in-lines and 287 cross-lines (<a href="#fig-ODT_survey_definition" class="quarto-xref">Figure&nbsp;5</a>).</p>
</section>
<section id="interpolation" class="level3">
<h3 class="anchored" data-anchor-id="interpolation">Interpolation</h3>
<p>Cropping and resampling are performed in one pass by interpolation onto the grid that defines the location of the OpendTect survey.&nbsp;The SciPy <code>interpolate</code> module contains the functions we need for this purpose.</p>
<p>The important task before running the interpolation&nbsp;is to create two sets of coordinates: one for the grid of our image and one for the target grid, i.e.&nbsp;the seismic survey.</p>
<p>As stated earlier, the coordinates of our input image were exported by&nbsp;QGIS when we created the image of the map. In Python, we load the image and its attached geographic metadata with the <code>rasterio</code> module (see <a href="https://nbviewer.jupyter.org/github/jobar8/Geophysics-Labs-Notebooks/blob/master/notebooks/02_Cropping_and_resampling_grid.ipynb">Jupyter notebook</a>). We could also directly open the .pgw file in a text editor and read the cell size and location of the upper left pixel.</p>
<p>Keep in mind when reading coordinates of raster images that these numbers could correspond to either the centre or the corner of the pixel. There are two conventions for registering images (gridline- and pixel-based) and both are equally used. For example, <code>rasterio</code> would give you the position of the corner of the upper-left pixel, while the world file gives you its centre.</p>
<p>In any case, constructing a grid of coordinates with Numpy is easy thanks to the <code>meshgrid</code> function:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 1-D arrays of coordinates</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(xmin,xmax,num<span class="op">=</span>ncols,endpoint<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.linspace(ymin,ymax,num<span class="op">=</span>nrows,endpoint<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 2-D arrays of coordinates</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>X,Y <span class="op">=</span> np.meshgrid(x,y)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> np.flipud(Y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The X and Y arrays give the coordinates <code>(X[i,j], Y[i,j])</code> of each pixel <code>(i,j)</code> in the image. Flipping the Y array upside-down is necessary because indices are counted from the top down, while the y-coordinate (northing) increases <em>northward</em>.</p>
<p>The arrays for the target grid are created slightly differently. First we create arrays of in-line and cross-line indices (trace numbers) as defined in OpendTect. Then the coordinates are calculated using the formulas of the <em>affine transformation</em> that are provided in <code>Survey Setup &gt; Coordinate settings</code> (advanced panel, <a href="#fig-ODT_survey_settings" class="quarto-xref">Figure&nbsp;6</a>).</p>
<div id="fig-ODT_survey_settings" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ODT_survey_settings-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/ODT_survey_coordinates_advanced_settings.png" class="lightbox" data-gallery="quarto-lightbox-gallery-6" title="Figure&nbsp;6: Equations of the affine transformation that gives X and Y coordinates from inline and crossline numbers."><img src="images/ODT_survey_coordinates_advanced_settings.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ODT_survey_settings-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6: Equations of the affine transformation that gives X and Y coordinates from inline and crossline numbers.
</figcaption>
</figure>
</div>
<p>The coordinates of the target grid are therefore given by:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>inline_limits <span class="op">=</span> np.arange(<span class="dv">1000</span>,<span class="dv">1280</span>,<span class="dv">1</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>xline_limits <span class="op">=</span> np.arange(<span class="dv">1000</span>,<span class="dv">1287</span>,<span class="dv">1</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>inline,xline <span class="op">=</span> np.meshgrid(inline_limits,xline_limits,indexing<span class="op">=</span><span class="st">'ij'</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># indexing starts from bottom-left corner</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>inline <span class="op">=</span> np.flipud(inline)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Now we can compute the coordinates</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>Xi <span class="op">=</span> <span class="fl">3491336.248</span> <span class="op">-</span> <span class="fl">3.19541219</span><span class="op">*</span>inline <span class="op">+</span> <span class="fl">9.4758042</span><span class="op">*</span>xline</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>Yi <span class="op">=</span> <span class="fl">7497848.4</span> <span class="op">+</span> <span class="fl">9.47383513</span><span class="op">*</span>inline <span class="op">+</span> <span class="fl">3.19552448</span><span class="op">*</span>xline</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The last stage consists in combining all these elements together by first creating the interpolation function with the first grid and then running it onto the second grid.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> np.column_stack((X.flatten(),Y.flatten()))</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>values <span class="op">=</span> indexedImage.flatten()</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>interp <span class="op">=</span> interpolate.NearestNDInterpolator(points,values)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>newImage <span class="op">=</span> interp((Xi,Yi))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It is important to use the <em>nearest-neighbour</em> interpolator here because we need to preserve the values of our indexed colours. Otherwise, the colours of our image could change in an unexpected way!</p>
<p>The result looks great and shows the map rotated in the frame of the 3D seismic survey (<a href="#fig-kevitsa_geology_rotated" class="quarto-xref">Figure&nbsp;7</a>). Note that the image is a bit bigger than the outline of the 3D because I have extended the target grid by 50 pixels on all sides (see the <a href="https://nbviewer.jupyter.org/github/jobar8/Geophysics-Labs-Notebooks/blob/master/notebooks/02_Cropping_and_resampling_grid.ipynb">Jupyter notebook</a> for the code to achieve that).</p>
<div id="fig-kevitsa_geology_rotated" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-kevitsa_geology_rotated-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/Kevitsa_geology_rotated.png" class="lightbox" data-gallery="quarto-lightbox-gallery-7" title="Figure&nbsp;7: Geological map of the Kevitsa area rotated in the local coordinate system of the seismic survey."><img src="images/Kevitsa_geology_rotated.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-kevitsa_geology_rotated-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7: Geological map of the Kevitsa area rotated in the local coordinate system of the seismic survey.
</figcaption>
</figure>
</div>
</section>
</section>
<section id="importing-the-grid-into-opendtect" class="level2">
<h2 class="anchored" data-anchor-id="importing-the-grid-into-opendtect">Importing the grid into OpendTect</h2>
<p>The final step is to actually import the grid of our indexed-colour rotated image into OpendTect. The grid will be imported as a 3D horizon geometry and the colour information will be imported as an attribute. Both operations can be performed at the same time. But first, our grid needs to be saved in a format that OpendTect can read, the simplest one being an ASCII column format.</p>
<p>Since we have deliberately created the new image to match the grid of the survey data, the inline and crossline trace numbers can be used instead of the X and Y coordinates. The code to make the ASCII text file is available in the Jupyter notebook.</p>
<p>Importing the file in OpendTect is easy:</p>
<ul>
<li><p>Go to Survey &gt; Import &nbsp;&gt; Horizon &gt; ASCII &gt; Geometry 3D…</p></li>
<li><p>Select the newly created .xyz file.</p></li>
<li><p>Add the colour indices (the pixel values) as an <em>attribute</em> called “Geology”.</p></li>
<li><p>Define the format by clicking “Define…”.</p></li>
<li><p>Select “Inl Crl” instead of “X Y” in the dropdown menu.</p></li>
</ul>
<p>The rest of the format definition should automatically be correct since we have added a Z column in the third position. Define the name of the output horizon and the Import Horizon window should look like <a href="#fig-ODT_Import_Window" class="quarto-xref">Figure&nbsp;8</a>.</p>
<div id="fig-ODT_Import_Window" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ODT_Import_Window-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/ODT_Import_Window.png" class="lightbox" data-gallery="quarto-lightbox-gallery-8" title="Figure&nbsp;8: Import Horizon window in OpendTect"><img src="images/ODT_Import_Window.png" class="img-fluid figure-img" style="width:70.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ODT_Import_Window-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8: Import Horizon window in OpendTect
</figcaption>
</figure>
</div>
</section>
<section id="displaying-the-map-in-opendtect" class="level2">
<h2 class="anchored" data-anchor-id="displaying-the-map-in-opendtect">Displaying the map in OpendTect</h2>
<p>Our new 3D horizon can now be added to the display by clicking on “3D Horizon” in the scene Tree, then click “Add…”. Select the horizon in the list and click OK. You should see a flat plane at depth = 0 with a single bright colour. This is because OpendTect displays the Z-values of the horizon by default. To show the actual colours of the geological map, right-click on “Z value” in the Tree, then “Select Attribute” and “Horizon Data (1)…”. Select “Geology” in the list.</p>
<section id="loading-the-correct-colormap" class="level3">
<h3 class="anchored" data-anchor-id="loading-the-correct-colormap">Loading the correct colormap</h3>
<p>The map should now be displayed in the 3D scene in the right location related to the seismic data. However, the colours are likely to be completely wrong! This is because there is one last piece missing: the Windows 8-bit palette we used for the quantization. It needs to be imported as a new “ColorTable” (<a href="#fig-new_colortable" class="quarto-xref">Figure&nbsp;9</a>). The file is available <a href="files/odt_win256_cm.txt">here</a>.</p>
<div id="fig-new_colortable" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-new_colortable-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/ODT_Import_new_colortable.png" class="lightbox" data-gallery="quarto-lightbox-gallery-9" title="Figure&nbsp;9: Loading the Windows 8-bit palette into OpendTect"><img src="images/ODT_Import_new_colortable.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-new_colortable-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9: Loading the Windows 8-bit palette into OpendTect
</figcaption>
</figure>
</div>
<p>To import the correct palette, follow these steps:</p>
<ul>
<li><p>go to Survey &gt; Import &gt; ColorTable…</p></li>
<li><p>Select Import from: File.</p></li>
<li><p>Browse to the location of the text file that contains the&nbsp;color table</p></li>
<li><p>Select “win_256” in the list of “Color table(s) to add”</p></li>
</ul>
<p>The final task is to assign the new Color Table to the “Geology” attribute. Select the attribute in the scene tree, then choose “Win_256” in the dropdown list of ColorTables. Make sure the range &nbsp;of the color scale goes from 0 to 255.</p>
<p>Et voila! The map is not displayed in all its glory together with the seismic data of the 3D survey (<a href="#fig-Map_in_ODT_view1" class="quarto-xref">Figure&nbsp;10</a> and <a href="#fig-Map_in_ODT_view2" class="quarto-xref">Figure&nbsp;11</a>).</p>
<div id="fig-Map_in_ODT_view1" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-Map_in_ODT_view1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/Map_in_ODT_view1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-10" title="Figure&nbsp;10: 3D view of the geological map in OpendTect."><img src="images/Map_in_ODT_view1.png" class="img-fluid figure-img" style="width:80.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-Map_in_ODT_view1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10: 3D view of the geological map in OpendTect.
</figcaption>
</figure>
</div>
<div id="fig-Map_in_ODT_view2" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-Map_in_ODT_view2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/Map_in_ODT_view2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-11" title="Figure&nbsp;11: 3D view of the geological map with seismic data of the Kevitsa 3D survey."><img src="images/Map_in_ODT_view2.png" class="img-fluid figure-img" style="width:80.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-Map_in_ODT_view2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;11: 3D view of the geological map with seismic data of the Kevitsa 3D survey.
</figcaption>
</figure>
</div>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>While not completely straightforward, importing geological maps in OpendTect is <em>possible!</em>&nbsp;;-)</p>
</section>
<section id="acknowledgements" class="level2">
<h2 class="anchored" data-anchor-id="acknowledgements">Acknowledgements</h2>
<p>The geological map and the 3D seismic survey were kindly made available through the Frank Arnott Award by&nbsp;First Quantum Minerals Ltd.&nbsp;The content of the dataset is re-used here with permission.</p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<p>Koivisto, E., Malehmir, A., Hellqvist, N., Voipio, T., Wijns, C., 2015. Building a 3D model of lithological contacts and near-mine structures in the Kevitsa mining and exploration site, Northern Finland: Constraints from 2D and 3D reflection seismic data. <em>Geophysical Prospecting</em> 63, 754–773. doi:10.1111/1365-2478.12252</p>
<p>Malehmir, A., Juhlin, C., Wijns, C., Urosevic, M., Valasti, P., Koivisto, E., 2012. 3D reflection seismic imaging for open-pit mine planning and deep exploration in the Kevitsa Ni-Cu-PGE deposit, northern Finland. <em>Geophysics</em> 77, WC95-WC108. doi:10.1190/geo2011-0468.1</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/josephbarraud\.dev");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
          // default icon
          link.classList.add("external");
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"selector":".lightbox","openEffect":"zoom","descPosition":"bottom","loop":false,"closeEffect":"zoom"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>